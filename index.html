<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nano Banana Pro v14</title>
    <style>
        :root {
            --bg-color: #0d0d0d;
            --card-bg: #161616;
            --text-color: #eaeaea;
            --accent: #ffe135;
            --accent-hover: #eacc28;
            --danger: #ff4444;
            --danger-hover: #cc3333;
            --border: #333;
            --modal-bg: rgba(0, 0, 0, 0.95);
        }
        body {
            font-family: system-ui, -apple-system, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            padding: 20px;
            display: flex;
            justify-content: center;
            min-height: 100vh;
        }
        .container {
            width: 100%;
            max-width: 800px;
        }
        
        h1 { text-align: center; color: var(--accent); margin: 0 0 5px 0; }
        .model-badge { text-align: center; font-size: 0.75em; color: #666; margin-bottom: 20px; font-family: monospace; }

        .card {
            background: var(--card-bg);
            padding: 15px;
            border-radius: 12px;
            border: 1px solid var(--border);
            margin-bottom: 15px;
        }

        label { display: block; color: #888; font-size: 0.8em; margin-bottom: 6px; font-weight: 600; text-transform: uppercase;}
        input, select, textarea {
            width: 100%;
            padding: 12px;
            background: #222;
            border: 1px solid var(--border);
            color: white;
            border-radius: 6px;
            box-sizing: border-box;
            margin-bottom: 10px;
        }
        textarea { min-height: 100px; resize: vertical; }
        input:focus, select:focus, textarea:focus { outline: 2px solid var(--accent); border-color: transparent; }

        /* Button Group */
        .btn-group { display: flex; gap: 10px; }

        .btn {
            flex: 1;
            padding: 14px;
            border: none;
            border-radius: 8px;
            font-weight: bold;
            cursor: pointer;
            transition: 0.2s;
            font-size: 1em;
        }
        .btn-primary { background: var(--accent); color: #000; }
        .btn-primary:hover { background: var(--accent-hover); }
        .btn-primary:disabled { background: #333; color: #666; cursor: not-allowed; }
        
        .btn-stop { background: var(--danger); color: white; display: none; }
        .btn-stop:hover { background: var(--danger-hover); }

        .btn-secondary { background: #333; color: #fff; margin-top: 5px; width: 100%;}
        .btn-secondary:hover { background: #444; }
        
        .btn-danger-small { background: #442222; color: #ff8888; margin-top: 5px; font-size: 0.8em; padding: 8px; width: 100%;}
        
        /* Input Image Grid */
        .image-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(60px, 1fr)); gap: 8px; margin-top: 10px; }
        .thumb-container { position: relative; aspect-ratio: 1; border-radius: 6px; overflow: hidden; border: 1px solid var(--border); cursor: pointer; }
        .thumb-container img { width: 100%; height: 100%; object-fit: cover; }
        .thumb-container:hover { border-color: var(--accent); }
        .delete-btn { position: absolute; top: 2px; right: 2px; background: var(--danger); color: white; border: none; width: 16px; height: 16px; border-radius: 50%; font-size: 10px; cursor: pointer; display: flex; align-items: center; justify-content: center; }

        /* Result Area */
        #resultArea { min-height: 50px; display: flex; flex-direction: column; gap: 10px; }
        #resultArea img {
            width: 100%;
            border-radius: 8px;
            border: 1px solid #333;
            cursor: zoom-in;
            display: block;
            margin-top: 10px;
        }
        .thought-label {
            color: var(--accent);
            font-size: 0.75em;
            font-weight: bold;
            text-transform: uppercase;
            margin-top: 10px;
            letter-spacing: 1px;
            border-bottom: 1px solid #333;
            padding-bottom: 5px;
        }
        .response-text {
            background: #222;
            padding: 15px;
            border-radius: 8px;
            border-left: 2px solid #555;
            white-space: pre-wrap;
            color: #ccc;
            font-size: 0.9em;
            line-height: 1.5;
            font-family: monospace;
        }
        .status-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            background: #111;
            border-radius: 8px;
            margin-bottom: 10px;
            font-family: monospace;
            font-size: 0.9em;
        }
        .timer { color: var(--accent); font-weight: bold; }
        
        .error-box {
            background: rgba(255, 68, 68, 0.1);
            border: 1px solid var(--danger);
            color: #ff8888;
            padding: 15px;
            border-radius: 8px;
            margin-top: 10px;
            word-wrap: break-word;
        }
        
        /* Raw Data Inspector */
        details { margin-top: 15px; border-top: 1px solid #333; padding-top: 10px; }
        summary { color: #888; cursor: pointer; font-size: 0.9em; font-family: monospace; outline: none; }
        .raw-json {
            background: #111;
            color: #0f0;
            padding: 15px;
            font-family: monospace;
            font-size: 0.75em;
            border-radius: 6px;
            white-space: pre-wrap;
            overflow-x: auto;
            margin-top: 10px;
            border: 1px solid #333;
            max-height: 200px;
        }

        /* Logs */
        #logArea {
            background: #000; color: #4f4;
            font-family: monospace; font-size: 0.8em;
            padding: 10px; height: 100px;
            overflow-y: auto; border-radius: 6px;
            margin-top: 10px; display: block;
        }

        /* Config Row */
        .config-row { display: flex; gap: 10px; flex-wrap: wrap; }
        .config-row > div { flex: 1; min-width: 100px; }

        /* Modal */
        .modal {
            display: none; position: fixed; z-index: 100;
            left: 0; top: 0; width: 100%; height: 100%;
            background-color: var(--modal-bg);
            backdrop-filter: blur(5px);
            align-items: center; justify-content: center;
            flex-direction: column; padding: 20px; box-sizing: border-box;
        }
        .modal-content { max-width: 90%; max-height: 80vh; object-fit: contain; border-radius: 8px; box-shadow: 0 0 30px rgba(0,0,0,0.8); }
        .modal-actions { display: flex; gap: 10px; margin-top: 15px; width: 100%; max-width: 500px; }
        .close-modal { position: absolute; top: 20px; right: 30px; color: #fff; font-size: 40px; font-weight: bold; cursor: pointer; }
    </style>
</head>
<body>

<div class="container">
    <h1>Nano Banana Pro v14</h1>
    <div class="model-badge">gemini-3-pro-image-preview | REST Stream</div>

    <!-- API Key -->
    <div class="card">
        <label>API Key</label>
        <input type="password" id="apiKey" placeholder="Enter Gemini API Key...">
    </div>

    <!-- Controls -->
    <div class="card">
        <label>Prompt</label>
        <textarea id="prompt" placeholder="Describe your image..."></textarea>

        <label>Input Images (Max 24)</label>
        <input type="file" id="fileInput" multiple accept="image/*" style="font-size: 0.9em;">
        <div class="image-grid" id="inputGrid"></div>
        <button class="btn btn-danger-small" onclick="clearImages()" id="clearBtn" style="display:none;">Clear All Images</button>

        <div class="config-row" style="margin-top:10px;">
            <div>
                <label>Aspect Ratio</label>
                <select id="aspectRatio">
                    <option value="auto">Auto</option>
                    <option value="1:1">1:1 Square</option>
                    <option value="16:9">16:9 Landscape</option>
                    <option value="9:16">9:16 Portrait</option>
                    <option value="4:3">4:3</option>
                    <option value="3:4">3:4</option>
                </select>
            </div>
            <div>
                <label>Resolution</label>
                <select id="resolution">
                    <option value="1K">1K (Standard)</option>
                    <option value="2K">2K (High Detail)</option>
                    <option value="4K">4K (Ultra Sharp)</option>
                </select>
            </div>
        </div>

        <br>
        <div class="btn-group">
            <button class="btn btn-primary" id="genBtn" onclick="generate()">Stream Generation</button>
            <button class="btn btn-stop" id="stopBtn" onclick="stopGeneration()">STOP</button>
        </div>
    </div>

    <!-- Logs -->
    <div id="logArea">System Ready.</div>

    <!-- Result -->
    <div class="card" id="resultCard" style="display:none;">
        <label>Result Stream</label>
        
        <!-- Status Bar with Timer -->
        <div class="status-bar" id="statusBar">
            <span id="statusText">Initializing...</span>
            <span class="timer" id="timer">0.0s</span>
        </div>

        <div id="resultArea"></div>
        
        <!-- Raw Debugger -->
        <details id="rawDebug">
            <summary>üõ†Ô∏è Streaming Data (Raw JSON Chunks)</summary>
            <div class="raw-json" id="rawJsonContent"></div>
        </details>
    </div>
</div>

<!-- Modal -->
<div id="modal" class="modal">
    <span class="close-modal" onclick="closeModal()">&times;</span>
    <img class="modal-content" id="modalImg">
    <div class="modal-actions" id="modalBtns"></div>
</div>

<script>
    // --- State ---
    let inputImages = []; 
    let abortController = null; // Controls the Stop button
    let timerInterval = null;   // Controls the clock

    // --- Local Storage ---
    const keyInput = document.getElementById('apiKey');
    if(localStorage.getItem('nb_api_key')) keyInput.value = localStorage.getItem('nb_api_key');
    keyInput.addEventListener('input', (e) => localStorage.setItem('nb_api_key', e.target.value));

    // --- Image Input Handling ---
    document.getElementById('fileInput').addEventListener('change', async (e) => {
        const files = Array.from(e.target.files);
        if (inputImages.length + files.length > 24) { alert("Max 24 images allowed."); return; }

        for(let file of files) {
            if(inputImages.length >= 24) break;
            const b64 = await toBase64(file);
            inputImages.push({
                id: Date.now() + Math.random(),
                mime: file.type,
                data: b64.split(',')[1],
                preview: b64
            });
        }
        renderInputGrid();
        e.target.value = '';
    });

    function renderInputGrid() {
        const grid = document.getElementById('inputGrid');
        grid.innerHTML = '';
        inputImages.forEach((img, index) => {
            const div = document.createElement('div');
            div.className = 'thumb-container';
            const image = document.createElement('img');
            image.src = img.preview;
            image.onclick = () => openModal(img.preview, false);
            const delBtn = document.createElement('button');
            delBtn.className = 'delete-btn';
            delBtn.innerHTML = '√ó';
            delBtn.onclick = (e) => { e.stopPropagation(); inputImages.splice(index, 1); renderInputGrid(); };
            div.appendChild(image);
            div.appendChild(delBtn);
            grid.appendChild(div);
        });
        document.getElementById('clearBtn').style.display = inputImages.length > 0 ? 'block' : 'none';
    }

    function clearImages() { inputImages = []; renderInputGrid(); }
    function toBase64(file) { return new Promise((res, rej) => { const r = new FileReader(); r.readAsDataURL(file); r.onload = () => res(r.result); r.onerror = rej; }); }

    // --- Modal ---
    const modal = document.getElementById('modal');
    const modalImg = document.getElementById('modalImg');
    const modalBtns = document.getElementById('modalBtns');

    function openModal(src, isResult) {
        modal.style.display = 'flex'; modalImg.src = src; modalBtns.innerHTML = ''; 
        if(isResult) {
            const dlBtn = document.createElement('button');
            dlBtn.className = 'btn btn-primary'; dlBtn.innerText = 'Download';
            dlBtn.onclick = () => { const a = document.createElement('a'); a.href = src; a.download = `nano-banana-${Date.now()}.jpg`; a.click(); };
            modalBtns.appendChild(dlBtn);
        }
    }
    function closeModal() { modal.style.display = 'none'; }
    modal.onclick = (e) => { if (e.target === modal) closeModal(); }

    // --- Logger ---
    const logArea = document.getElementById('logArea');
    function log(msg) {
        const time = new Date().toLocaleTimeString('en-GB');
        logArea.innerHTML += `<div><span style="color:#666">[${time}]</span> ${msg}</div>`;
        logArea.scrollTop = logArea.scrollHeight;
    }

    // --- STOP FUNCTIONALITY ---
    function stopGeneration() {
        if (abortController) {
            abortController.abort(); // Kills the fetch request
            abortController = null;
            log('üõë Generation stopped by user.');
            document.getElementById('statusText').innerText = "Stopped by User";
            document.getElementById('statusText').style.color = "#ff4444";
            endReset();
        }
    }

    function endReset() {
        clearInterval(timerInterval);
        document.getElementById('genBtn').disabled = false;
        document.getElementById('stopBtn').style.display = 'none';
    }

    // --- CORE GENERATION LOGIC ---
    async function generate() {
        const key = keyInput.value;
        if(!key) return alert('API Key Required');

        let promptText = document.getElementById('prompt').value;
        const aspect = document.getElementById('aspectRatio').value;
        const resolution = document.getElementById('resolution').value;
        
        const btn = document.getElementById('genBtn');
        const stopBtn = document.getElementById('stopBtn');
        const resArea = document.getElementById('resultArea');
        const rawJsonContent = document.getElementById('rawJsonContent');
        const statusText = document.getElementById('statusText');
        const timerDisplay = document.getElementById('timer');

        // Reset UI
        btn.disabled = true;
        stopBtn.style.display = 'block'; // Show Stop Button
        
        resArea.innerHTML = ''; 
        rawJsonContent.innerText = '';
        document.getElementById('resultCard').style.display = 'block';
        logArea.innerHTML = ''; 

        // Start Timer
        let startTime = Date.now();
        timerDisplay.innerText = "0.0s";
        statusText.innerText = "Connecting...";
        statusText.style.color = "#eaeaea";
        
        if(timerInterval) clearInterval(timerInterval);
        timerInterval = setInterval(() => {
            const elapsed = ((Date.now() - startTime) / 1000).toFixed(1);
            timerDisplay.innerText = elapsed + "s";
        }, 100);

        // --- 1. CONFIGURATION ---
        const imageConfig = {};
        // Matching Bash Script Structure: image_size (snake_case)
        if (resolution) imageConfig.image_size = resolution; // "1K", "2K", "4K"
        if (aspect !== 'auto') imageConfig.aspectRatio = aspect; 

        const MODEL_NAME = "gemini-3-pro-image-preview";
        
        // --- 2. PREPARE PAYLOAD ---
        // NOTE: We append a small instruction to encourage text output (thoughts)
        const finalPrompt = promptText + " (Briefly describe your plan/thoughts for the image first, then generate it.)";

        let parts = [{ text: finalPrompt }];
        inputImages.forEach((img) => { 
            parts.push({ inline_data: { mime_type: img.mime, data: img.data } }); 
        });

        const payload = {
            contents: [{ parts: parts }],
            // Standard Safety Settings
            safetySettings: [
                { category: "HARM_CATEGORY_HARASSMENT", threshold: "BLOCK_ONLY_HIGH" },
                { category: "HARM_CATEGORY_HATE_SPEECH", threshold: "BLOCK_ONLY_HIGH" },
                { category: "HARM_CATEGORY_SEXUALLY_EXPLICIT", threshold: "BLOCK_ONLY_HIGH" },
                { category: "HARM_CATEGORY_DANGEROUS_CONTENT", threshold: "BLOCK_ONLY_HIGH" }
            ],
            generationConfig: { 
                responseModalities: ["TEXT", "IMAGE"], 
                imageConfig: imageConfig
            }
        };

        const URL = `https://generativelanguage.googleapis.com/v1beta/models/${MODEL_NAME}:streamGenerateContent?key=${key}&alt=sse`;

        log(`Requesting...`);

        // Initialize AbortController
        abortController = new AbortController();

        try {
            const response = await fetch(URL, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload),
                signal: abortController.signal // Connects the Stop Button
            });

            if (!response.ok) {
                const errText = await response.text();
                try {
                    const errJson = JSON.parse(errText);
                    throw new Error(errJson.error.message);
                } catch(e) {
                    throw new Error(`HTTP ${response.status}: ${errText}`);
                }
            }

            // --- 3. STREAM READER ---
            const reader = response.body.getReader();
            const decoder = new TextDecoder();
            let buffer = '';
            
            statusText.innerText = "Streaming Thoughts...";
            
            while (true) {
                const { value, done } = await reader.read();
                if (done) break;

                const chunk = decoder.decode(value, { stream: true });
                buffer += chunk;

                const lines = buffer.split('\n');
                buffer = lines.pop(); 

                for (const line of lines) {
                    if (line.startsWith('data: ')) {
                        const jsonStr = line.slice(6);
                        if (jsonStr.trim() === '[DONE]') continue;

                        try {
                            const data = JSON.parse(jsonStr);
                            rawJsonContent.innerText += JSON.stringify(data, null, 2) + ",\n";

                            const candidate = data.candidates?.[0];
                            if (candidate) {
                                // A) Handle Text Stream (Thoughts/Reasoning)
                                const textPart = candidate.content?.parts?.find(p => p.text);
                                if (textPart) {
                                    let txtDiv = document.getElementById('stream-text');
                                    if(!txtDiv) {
                                        const label = document.createElement('div');
                                        label.className = 'thought-label';
                                        label.innerText = 'Model Thoughts:';
                                        resArea.appendChild(label);

                                        txtDiv = document.createElement('div');
                                        txtDiv.id = 'stream-text';
                                        txtDiv.className = 'response-text';
                                        resArea.appendChild(txtDiv);
                                    }
                                    txtDiv.innerText += textPart.text;
                                }

                                // B) Handle Image Chunk
                                const imgPart = candidate.content?.parts?.find(p => p.inline_data || p.inlineData);
                                if (imgPart) {
                                    log('Image payload received!');
                                    statusText.innerText = "Image Received!";
                                    statusText.style.color = "#4f4";
                                    
                                    const imgObj = imgPart.inline_data || imgPart.inlineData;
                                    
                                    const img = document.createElement('img');
                                    img.src = `data:${imgObj.mime_type};base64,${imgObj.data}`;
                                    img.onclick = () => openModal(img.src, true);
                                    
                                    resArea.appendChild(img);
                                    
                                    const caption = document.createElement('div');
                                    caption.innerText = `Generated at ${resolution}`;
                                    caption.style.textAlign='center'; caption.style.color='#666'; caption.style.fontSize='0.8em';
                                    resArea.appendChild(caption);
                                }
                            }
                        } catch (e) {
                            console.warn('JSON Parse error on chunk', e);
                        }
                    }
                }
            }
            log('Stream finished.');
            statusText.innerText = "Complete";

        } catch(e) {
            if (e.name === 'AbortError') {
                // Already handled by stopGeneration()
            } else {
                log(`ERROR: ${e.message}`);
                resArea.innerHTML += `<div class="error-box"><strong>Error:</strong> ${e.message}</div>`;
                statusText.innerText = "Error";
                statusText.style.color = "#ff4444";
            }
        } finally {
            endReset();
        }
    }
</script>
</body>
</html>